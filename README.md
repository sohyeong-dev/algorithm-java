# algorithm-java
알고리즘 연습 with 자바

### 시간 복잡도

1초 = 1억 번의 연산
> - 10!
> - 2^20
> - 1만^2

> logN은 상수 급

---

### 자료구조

```java
import java.util.*;
```

#### 배열

```java
Arrays.toString(배열);  // 1차원 배열의 값들을 출력
Arrays.deepToString(배열);  // 2차원 이상의 배열의 값들을 출력
Arrays.fill(배열, 값);  // 배열의 모든 값을 특정 값으로 변경 (초기화)
Arrays.sort(배열);  // 배열을 오름차순으로 정렬
// 2차원 배열 첫번째 값으로 정렬하되 같으면 두번째 값으로 정렬
Arrays.sort(배열, (a, b) -> ((a[0] != b[0]) ? a[0] - b[0] : a[1] - b[1]));
```

#### 리스트

- ArrayList: 배열
```java
// 정렬
Collections.sort(list, (a , b) -> a.length() - b.length());
```
- LinkedList: 이중 연결 리스트(Deque)
```java
// Head
deque.add_front();  // 큐의 앞부분에 삽입
deque.get_front();
deque.delete_front();  // 큐의 앞부분에서 삭제

// Tail
deque.add_rear();  // 큐의 뒷부분에 삽입
deque.get_rear();
deque.delete_rear();  // 큐의 뒷부분에서 삭제
```

#### 스택
Vector

```java
Stack<Integer> stack = new Stack<>();

stack.push();  // 스택에 데이터 삽입
stack.pop();  // 스택의 맨 위 데이터를 제거하고 그 값을 반환
stack.peek();  // 스택의 맨 위에 있는 요소의 값을 반환
stack.isEmpty();  // 스택이 비어 있으면 true, 그렇지 않으면 false
stack.toString();  // 스택에 저장된 값을 문자열로 변환
```
백준) 17608 막대기, 1874 스택 수열, 2493 탑, 17298 오큰수

#### 큐
LinkedList

```java
Queue<Integer> queue = new LinkedList<>();

queue.offer();  // 큐에 데이터를 추가
queue.poll();  // 큐에서 데이터를 삭제
queue.peek();  // 맨 앞의 데이터를 반환
queue.isEmpty();  // 큐가 비어 있으면 true, 그렇지 않으면 false
queue.toString();  // 큐에 저장된 값을 문자열로 변환
```
백준) 2164 카드2, 1158 요세푸스 문제

#### 이진 트리
1) 배열 `Stack<Integer>` - 1: 루트 노드
2) 배열 - parent[i] = 부모 노드 idx
3) 배열 {left, right}
4) 인접 리스트: 2차원 리스트 `ArrayList<Integer[]>`

#### 그래프
1) 에지 리스트 {출발 노드, 도착 노드, 가중치}
2) 인접 행렬: 2차원 배열
3) 인접 리스트: ArrayList<Integer[]>[]

---

### 알고리즘

#### 구간 합
합 배열을 이용 `S[i] = S[i - 1] + A[i]`

백준) 11659 구간 합 구하기4 (1차원 배열의 구간 합), 11660 구간 합 구하기5 (2차원 배열의 구간 합)

#### 투 포인터
두 개의 포인터를 활용하여 시작 인덱스와 끝 인덱스를 지정

백준) 2018 수들의 합, 12891 DNA 비밀번호

#### 완전 탐색
모든 경우의 수를 탐색하여 정답을 찾는 방법

##### 순열

백준) 9742 순열

##### 조합

백준) 15650 N과M1, 1759 암호 만들기

##### 부분집합

백준) 1182 부분수열의 합, 2961 도영이가 만든 맛있는 음식

##### DFS
1) 재귀
   1. 인접 리스트로 연결 표현, 방문 마킹 배열로 중복 방지, 다음 탐색 노드 마킹 배열 변경
   2. 재귀 함수 호출 -> 인접 노드 방문 배열 중복 체크 -> 마킹 배열 변경 -> 재귀 함수 호출
   3. 마킹 배열 해제
2) 스택
  1. 인접 리스트로 연결 표현, 방문 마킹 배열로 중복 방지, 스택으로 다음 탐색 노드 저장
     ```java
     stack.push(start);
     ```
  3. 스택에서 노드를 꺼냄 -> 탐색 순서에 꺼낸 노드를 기록 -> 인접 노드를 스택에 삽입하며 방문 배열 체크
     ```java
     node = stack.pop();
     // 중복 체크
     // 마킹 배열 변경
     for (next: list[node]) {
       stack.push(next);
     }
     ```
  5. 스택 자료구조에 값이 없을 때까지 반복 - 이미 다녀간 노드는 삽입하지 않음
     ```java
     while(!stack.isEmpty()) {}
     ```

##### BFS
> 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.
1) 큐

##### 백트래킹
해를 찾는 도중 막힌 경우 되돌아가서 다시 해를 찾아가는 기법
1) 재귀를 이용한 DFS

백준) 9663 N-Queen (가로/세로/대각선)

<details>
   <summary>체스 - 퀸</summary>
   상하좌우, 대각선 4방향으로 거리 제한 없이 이동할 수 있는 기물
</details>

<details>
   <summary>대각선</summary>
   abs(y - y`) == abs(x - x')

   기울기 = 1
</details>

##### 그리디 알고리즘
1) 해 선택: 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2) 적절성 검사: 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3) 해 검사: 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다.
4) 전체 문제를 해결하지 못한다면 1)로 돌아가 같은 과정을 반복한다.

##### 이진탐색
1) 오름차순으로 정렬한다.
2) 중앙값 > 타깃 데이터일 떄 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3) 중앙값 < 타깃 데이터일 때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
4) 중앙값 == 타깃 데이터일 때 탐색을 종료한다.
5) start 와 end 가 엇갈린 경우 탐색을 종료한다. => 값이 없는 경우
