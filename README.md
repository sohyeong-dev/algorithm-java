# 알고리즘 연습 with 자바

### 시간 복잡도

1초 = 1억 번의 연산
> - 10!
> - 2^20
> - 1만^2

> logN은 상수 급

---

### 자료구조

```java
import java.util.*;
```

#### 배열

```java
Arrays.toString(배열);  // 1차원 배열의 값들을 출력
Arrays.deepToString(배열);  // 2차원 이상의 배열의 값들을 출력
Arrays.fill(배열, 값);  // 배열의 모든 값을 특정 값으로 변경 (초기화)
Arrays.sort(배열);  // 배열을 오름차순으로 정렬
// 2차원 배열 첫번째 값으로 정렬하되 같으면 두번째 값으로 정렬
Arrays.sort(배열, (a, b) -> ((a[0] != b[0]) ? a[0] - b[0] : a[1] - b[1]));
```

#### 리스트

- ArrayList: 배열
```java
// 정렬
Collections.sort(list, (a , b) -> a.length() - b.length());
```
- LinkedList: 이중 연결 리스트(Deque)
```java
// Head
deque.add_front();  // 큐의 앞부분에 삽입
deque.get_front();
deque.delete_front();  // 큐의 앞부분에서 삭제

// Tail
deque.add_rear();  // 큐의 뒷부분에 삽입
deque.get_rear();
deque.delete_rear();  // 큐의 뒷부분에서 삭제
```

#### 스택
Vector

```java
Stack<Integer> stack = new Stack<>();

stack.push();  // 스택에 데이터 삽입
stack.pop();  // 스택의 맨 위 데이터를 제거하고 그 값을 반환
stack.peek();  // 스택의 맨 위에 있는 요소의 값을 반환
stack.isEmpty();  // 스택이 비어 있으면 true, 그렇지 않으면 false
stack.toString();  // 스택에 저장된 값을 문자열로 변환
```
백준) 17608 막대기, 1874 스택 수열, 2493 탑, 17298 오큰수

#### 큐
LinkedList

```java
Queue<Integer> queue = new LinkedList<>();

queue.offer();  // 큐에 데이터를 추가
queue.poll();  // 큐에서 데이터를 삭제
queue.peek();  // 맨 앞의 데이터를 반환
queue.isEmpty();  // 큐가 비어 있으면 true, 그렇지 않으면 false
queue.toString();  // 큐에 저장된 값을 문자열로 변환
```
백준) 2164 카드2, 1158 요세푸스 문제

#### 이진 트리
1) 배열 `Stack<Integer>` - 1: 루트 노드
2) 배열 - parent[i] = 부모 노드 idx
3) 배열 {left, right}
4) 인접 리스트: 2차원 리스트 `ArrayList<Integer[]>`

#### 그래프
1) 에지 리스트 {출발 노드, 도착 노드, 가중치}
2) 인접 행렬: 2차원 배열
3) 인접 리스트: ArrayList<Integer[]>[]

#### 최소 신장 트리
: 그래프 내 모든 정점을 포함하는 트리 중 간선들의 가중치 합이 최소인 트리
- N 개 정점을 가지는 그래프에서 N-1 개의 간선으로 연결된 형태
- 사이클을 포함하지 않음

#### 우선순위 큐
PriorityQueue ( 최소 Heap )
: 우선순위가 가장 높은 데이터를 가장 먼저 삭제
```java
PriorityQueue<Integer> pq = new PriorityQueue<>();

pq.offer();   // 데이터를 추가
pq.poll();   // 데이터를 삭제
pq.peek();   // 데이터를 반환
pq.isEmpty();   // 비어 있으면 true, 그렇지 않으면 false
```

---

### 알고리즘

#### 구간 합
합 배열을 이용 `S[i] = S[i - 1] + A[i]`

백준) 11659 구간 합 구하기4 (1차원 배열의 구간 합), 11660 구간 합 구하기5 (2차원 배열의 구간 합)

#### 투 포인터
두 개의 포인터를 활용하여 시작 인덱스와 끝 인덱스를 지정

백준) 2018 수들의 합, 12891 DNA 비밀번호

#### 완전 탐색
모든 경우의 수를 탐색하여 정답을 찾는 방법

##### 순열

백준) 9742 순열

##### 조합

백준) 15650 N과M1, 1759 암호 만들기

##### 부분집합

백준) 1182 부분수열의 합, 2961 도영이가 만든 맛있는 음식

##### DFS
1) 재귀
   1. 인접 리스트로 연결 표현, 방문 마킹 배열로 중복 방지, 다음 탐색 노드 마킹 배열 변경
   2. 재귀 함수 호출 -> 인접 노드 방문 배열 중복 체크 -> 마킹 배열 변경 -> 재귀 함수 호출
   3. 마킹 배열 해제
2) 스택
  1. 인접 리스트로 연결 표현, 방문 마킹 배열로 중복 방지, 스택으로 다음 탐색 노드 저장
     ```java
     stack.push(start);
     ```
  3. 스택에서 노드를 꺼냄 -> 탐색 순서에 꺼낸 노드를 기록 -> 인접 노드를 스택에 삽입하며 방문 배열 체크
     ```java
     node = stack.pop();
     // 중복 체크
     // 마킹 배열 변경
     for (next: list[node]) {
       stack.push(next);
     }
     ```
  5. 스택 자료구조에 값이 없을 때까지 반복 - 이미 다녀간 노드는 삽입하지 않음
     ```java
     while(!stack.isEmpty()) {}
     ```

##### BFS
> 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.
1) 큐

##### 백트래킹
해를 찾는 도중 막힌 경우 되돌아가서 다시 해를 찾아가는 기법
1) 재귀를 이용한 DFS

백준) 9663 N-Queen (가로/세로/대각선)

<details>
   <summary>체스 - 퀸</summary>
   상하좌우, 대각선 4방향으로 거리 제한 없이 이동할 수 있는 기물
</details>

<details>
   <summary>대각선</summary>
   abs(y - y`) == abs(x - x')

   기울기 = 1
</details>

##### 그리디 알고리즘
1) 해 선택: 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2) 적절성 검사: 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3) 해 검사: 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다.
4) 전체 문제를 해결하지 못한다면 1)로 돌아가 같은 과정을 반복한다.

##### 이진탐색
1) 오름차순으로 정렬한다.
2) 중앙값 > 타깃 데이터일 떄 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3) 중앙값 < 타깃 데이터일 때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
4) 중앙값 == 타깃 데이터일 때 탐색을 종료한다.
5) start 와 end 가 엇갈린 경우 탐색을 종료한다. => 값이 없는 경우

##### 유니온 파인드
: 두 노드가 같은 그래프에 속하는지 판별하는 알고리즘 (DFS를 사용)  
`int[] parent`
1) Union 연산: 노드를 합치는 연산  
   union 함수: 트리 압축
   ```java
   function union (int x, int y) {
      x = find(x);
      y = find(y);

      if (x != y) {
         if (x < y) parent[y] = x;
         else parent[x] = y;
      }
   }   
   ```
3) Find 연산: 루트 노드를 찾는 연산  
   find 함수: 루트 노드 탐색 (재귀)
   ```java
   function find(int x) {
      if (parent[x] == x) return x;
      return parent[x] = find(parent[x]);
   }
   ```

##### 크루스칼 알고리즘
: (그리디) 유니온 파인트를 사용해서 최소신장트리를 구함

최소의 비용이 드는 간선들부터 선택해가는 방식
1) 그래프의 간선들을 가중치의 오름차순으로 정렬 (그리디 알고리즘)
2) 정렬된 간선 중 순서대로 사이클을 형성하지 않는 간선 선택 (유니온 파인드)

##### 다익스트라 알고리즘
: 가중치가 주어진 그래프에서 최단 거리를 구하는 알고리즘 (DP, 그리디)
- 출발 노드와 모든 노드 간의 최단 거리 탐색 (1:n)
- 간선의 가중치는 항상 양수이어야함
- 인접 리스트 (연결 리스트)
- 최단거리 배열 초기화 (출발 노드 = 0, 나머지 = INF)
- 한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾음

##### 플로이드 워셜 알고리즘
: (다이나믹 프로그래밍)
- 모든 노드에서 모든 노드로의 최단 거리 탐색
- 인접 행렬
- 2차원 리스트에 최단 거리 정보를 저장

1) 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
2) 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화

##### 벨만 포드 알고리즘

##### 프림 알고리즘

##### 위상 정렬 알고리즘
최소 신장 트리 2개: 가장 비용이 큰 간선을 제거
1) 진입 차수가 0인 노드를 큐에 넣는다
2) 큐 자료구조에 값이 없을 때까지 반복
3) 큐에서 노드를 꺼냄 -> 간선 제거
   ```java
   foreach(int i: graph[now]) {
      indegree[i] -= 1;
      // 간선 정보를 확인하여 결과 테이블 갱신
      if (indegree[i] == 0) {
         queue.offer(i);
      }
   }
   ```
5)  -> 탐색 순서에 꺼낸 노드를 기록 -> 인접 노드를 스택에 삽입하며 방문 배열 체크 
